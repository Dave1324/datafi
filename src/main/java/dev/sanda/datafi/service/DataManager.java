package dev.sanda.datafi.service;

import static com.google.common.collect.Maps.immutableEntry;
import static dev.sanda.datafi.DatafiStaticUtils.*;

import com.google.common.collect.Lists;
import dev.sanda.datafi.DatafiStaticUtils;
import dev.sanda.datafi.dto.FreeTextSearchPageRequest;
import dev.sanda.datafi.dto.Page;
import dev.sanda.datafi.persistence.Archivable;
import dev.sanda.datafi.persistence.GenericDao;
import dev.sanda.datafi.reflection.cached_type_info.CachedEntityTypeInfo;
import dev.sanda.datafi.reflection.runtime_services.ReflectionCache;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.*;
import java.util.stream.Collectors;
import javax.annotation.PostConstruct;
import javax.persistence.*;
import lombok.*;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.IterableUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Example;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;

@Service
@Slf4j
@SuppressWarnings("unchecked")
@NoArgsConstructor
@RequiredArgsConstructor
public class DataManager<T> {

  @Autowired
  private EntityManager entityManager;

  @NonNull
  @Getter
  private Class<T> clazz;

  @Getter
  private String clazzSimpleName;

  private String clazzSimpleNamePlural;
  private String idTypeSimpleName;
  private CachedEntityTypeInfo cachedEntityTypeInfo;

  @Autowired
  protected ReflectionCache reflectionCache;

  @Setter
  @Value("#{new Boolean('${datafi.logging-enabled:true}')}")
  private Boolean loggingEnabled;

  /**
   * compile a list of all the the jpa repositories which were
   * autogenerated at compile time, and map each data access object
   * - or 'dao' to the name of its respective jpa repository.
   */
  private Map<String, GenericDao> daoMap;
  private GenericDao dao;

  @Autowired //autowiring daos via proxy because cannot autowire directly in abstract class
  private DaoCollector daoCollector;

  /*@Autowired
    private EntityTypeRuntimeResolver<T> typeRuntimeResolver;*/

  public void setType(Class<T> clazz) {
    this.clazz = clazz;
    setClazzSimpleName(clazz);
    dao = daoMap.get(clazzSimpleName);
    cachedEntityTypeInfo =
      reflectionCache.getEntitiesCache().get(clazzSimpleName);
  }

  @PostConstruct
  private void init() {
    setClazzSimpleName(clazz);
    log.trace(
      "Running @PostConstruct init method for DataManager<{}>",
      clazzSimpleName
    );
    daoMap = toServicesMap(daoCollector.getDaos(), "Dao");
    if (clazz != null) setType(clazz);
  }

  private void setClazzSimpleName(Class<T> clazz) {
    clazzSimpleName =
      this.clazz != null ? this.clazz.getSimpleName() : "Object";
    clazzSimpleNamePlural = toPlural(clazzSimpleName);
    idTypeSimpleName =
      this.clazz != null
        ? reflectionCache
          .getEntitiesCache()
          .get(clazzSimpleName)
          .getIdField()
          .getType()
          .getSimpleName()
        : "Object";
  }

  private void logTrace(String method, String msg, Object... args) {
    if (!loggingEnabled) return;
    log.trace("DataManager<{}>." + method + " " + msg, clazzSimpleName, args);
  }

  private void logInfo(String method, String msg, Object... args) {
    if (!loggingEnabled) return;
    log.info("DataManager<{}>." + method + " " + msg, clazzSimpleName, args);
  }

  private void logError(String method, String msg, Object... args) {
    if (!loggingEnabled) return;
    log.error("DataManager<{}>." + method + " " + msg, clazzSimpleName, args);
  }

  public List<T> findAll() {
    final List all = dao.findAll();
    logInfo("findAll()", "fetched {} {}", all.size(), clazzSimpleNamePlural);
    return all;
  }

  public EntityManager entityManager() {
    return entityManager;
  }

  public List<T> findAll(Sort sort) {
    final List all = dao.findAll(sort);
    logInfo(
      "findAll(Sort sort)",
      "fetched {} {}, sorted by {}",
      all.size(),
      clazzSimpleNamePlural,
      sort.toString()
    );
    return all;
  }

  public org.springframework.data.domain.Page findAll(Pageable pageable) {
    final org.springframework.data.domain.Page all = dao.findAll(pageable);
    logInfo(
      "findAll(Pageable pageable)",
      "fetched {} {}, in {} pages",
      all.getTotalElements(),
      clazzSimpleNamePlural,
      all.getTotalPages()
    );
    return all;
  }

  public List<T> findAllById(Iterable<?> iterable) {
    final List allById = dao.findAllById(iterable);
    logInfo(
      "findAllById(Iterable<{}> iterable)",
      "fetched {} {} by id",
      idTypeSimpleName,
      allById.size(),
      clazzSimpleNamePlural
    );
    return allById;
  }

  public long count() {
    final long count = dao.count();
    logInfo(
      "count()",
      "counted a total of {} {}",
      count,
      clazzSimpleNamePlural
    );
    return count;
  }

  public void deleteById(Object id) {
    dao.deleteById(id);
    logInfo(
      "deleteById({} id)",
      "deleted {} by id {}",
      idTypeSimpleName,
      clazzSimpleName,
      id
    );
  }

  public void delete(T t) {
    dao.delete(t);
    logInfo(
      "delete({} {})",
      "deleted {} with id {}",
      clazzSimpleName,
      toCamelCase(clazzSimpleName),
      clazzSimpleName,
      reflectionCache.getEntitiesCache().get(clazzSimpleName).getId(t)
    );
  }

  public void deleteAll(Iterable<? extends T> iterable) {
    dao.deleteAll(iterable);
    logInfo(
      "deleteAll(Iterable<{}> iterable)",
      "deleted {} {}",
      clazzSimpleName,
      Lists.newArrayList(iterable).size(),
      clazzSimpleNamePlural
    );
  }

  public void deleteAll() {
    final long count = count();
    dao.deleteAll();
    logInfo("deleteAll()", "deleted all {} {}", count, clazzSimpleNamePlural);
  }

  public <S extends T> S save(S s) {
    final S saved = (S) dao.save(s);
    logInfo(
      "save({} {})",
      "saved {}: {}",
      clazzSimpleName,
      toCamelCase(clazzSimpleName),
      clazzSimpleName,
      s.toString()
    );
    return saved;
  }

  public <S extends T> List<S> saveAll(Iterable<S> iterable) {
    final List list = dao.saveAll(iterable);
    logInfo(
      "saveAll(Iterable<{}> iterable)",
      "saved {} {}",
      clazzSimpleName,
      list.size(),
      clazzSimpleNamePlural
    );
    return list;
  }

  public <S extends T> List<S> saveAllAndFlush(Iterable<S> iterable) {
    final List list = dao.saveAll(iterable);
    dao.flush();
    logInfo(
      "saveAll(Iterable<{}> iterable)",
      "saved {} {}",
      clazzSimpleName,
      list.size(),
      clazzSimpleNamePlural
    );
    return list;
  }

  public Optional<T> findById(Object id) {
    final Optional o = dao.findById(id);
    logInfo(
      "findById({} id)",
      o.isPresent() ? "fetched {} by id {}" : "could not find {} by id {}",
      idTypeSimpleName,
      clazzSimpleName,
      id
    );
    return o;
  }

  public boolean existsById(Object id) {
    final boolean exists = dao.existsById(id);
    logInfo(
      "existsById({} id)",
      exists
        ? "validated existence of {} by id {}"
        : "determined non-existence of {} by id {}",
      idTypeSimpleName,
      clazzSimpleName,
      id
    );
    return exists;
  }

  public void flush() {
    dao.flush();
    logTrace("flush()", "flushed JpaRepository persistence context");
  }

  public <S extends T> S saveAndFlush(S s) {
    final S saved = (S) dao.saveAndFlush(s);
    logInfo(
      "saveAndFlush({} {})",
      "saved and flushed {}: {}",
      clazzSimpleName,
      toCamelCase(clazzSimpleName),
      clazzSimpleName,
      s.toString()
    );
    return saved;
  }

  public void deleteInBatch(Iterable<T> iterable) {
    dao.deleteInBatch(iterable);
    logInfo(
      "deleteInBatch(Iterable<{}> iterable)",
      "deleted batch of {} {}",
      clazzSimpleName,
      IterableUtils.size(iterable),
      clazzSimpleNamePlural
    );
  }

  public void deleteAllInBatch() {
    dao.deleteAllInBatch();
    logInfo("deleteAllInBatch()", "deleted all {}", clazzSimpleNamePlural);
  }

  public T getOne(Object id) {
    final T fetched = (T) dao.getOne(id);
    logInfo(
      "getOne({} id)",
      "fetched one {} by id {}",
      idTypeSimpleName,
      clazzSimpleName,
      id.toString()
    );
    return fetched;
  }

  public <S extends T> Optional<S> findOne(Example<S> example) {
    final Optional fetched = dao.findOne(example);
    logInfo(
      "findOne(Example<{}> example)",
      fetched.isPresent()
        ? "fetched one {} by provided example"
        : "could not find {} by provided example",
      clazzSimpleName,
      clazzSimpleName
    );
    return fetched;
  }

  public <S extends T> List<S> findAll(Example<S> example) {
    final List all = dao.findAll(example);
    logInfo(
      "findAll(Example<{}> example)",
      "found all {} by provided example",
      clazzSimpleName
    );
    return all;
  }

  public <S extends T> List<S> findAll(Example<S> example, Sort sort) {
    final List all = dao.findAll(example, sort);
    logInfo(
      "findAll(Example<{}> example)",
      "found all {} {} by provided example, sorted by {}",
      clazzSimpleName,
      all.size(),
      clazzSimpleNamePlural,
      sort.toString()
    );
    return all;
  }

  public <S extends T> org.springframework.data.domain.Page findAll(
    Example<S> example,
    Pageable pageable
  ) {
    final org.springframework.data.domain.Page all = dao.findAll(
      example,
      pageable
    );
    logInfo(
      "findAll(Example<{}> example)",
      "found all {} {} by provided example, in {} page(s)",
      clazzSimpleName,
      all.getTotalElements(),
      clazzSimpleNamePlural,
      all.getTotalPages()
    );
    return all;
  }

  public <S extends T> long count(Example<S> example) {
    final long count = dao.count(example);
    logInfo(
      "count(Example<{}> example)",
      "counted {} {} by provided example",
      clazzSimpleName,
      count,
      clazzSimpleNamePlural
    );
    return count;
  }

  public <S extends T> boolean exists(Example<S> example) {
    final boolean exists = dao.exists(example);
    logInfo(
      "exists(Example<{}> example)",
      exists
        ? "validated existence of {} by provided example"
        : "determined non-existence of {} by provided example",
      clazzSimpleName,
      clazzSimpleName
    );
    return exists;
  }

  public List<T> findBy(String attributeName, Object attributeValue) {
    try {
      final Class<?> attributeValueClass = attributeValue.getClass();
      Class<?>[] params = new Class<?>[] { attributeValueClass };
      String resolverName = "findBy" + toPascalCase(attributeName);
      Method methodToInvoke = getMethodToInvoke(resolverName, params, dao);
      final List<T> result = (List<T>) methodToInvoke.invoke(
        dao,
        new Object[] { attributeValue }
      );
      logInfo(
        "findBy(String attributeName, {} attributeValue)",
        "found {} {} by field {} with matching value of {}",
        attributeValueClass.getSimpleName(),
        result.size(),
        clazzSimpleNamePlural,
        attributeValue.toString()
      );
      return result;
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  public Optional<T> findByUnique(String attributeName, Object attributeValue) {
    try {
      final Class<?> attributeValueClass = attributeValue.getClass();
      Class<?>[] params = new Class<?>[] { attributeValueClass };
      String resolverName = "findBy" + toPascalCase(attributeName);
      Method methodToInvoke = getMethodToInvoke(resolverName, params, dao);
      final Optional<T> result = (Optional<T>) methodToInvoke.invoke(
        dao,
        new Object[] { attributeValue }
      );
      logInfo(
        "findByUnique(String attributeName, {} attributeValue)",
        result.isPresent()
          ? "found {} by field {} with matching value of {}"
          : "could not find {} by field {} with matching value of {}",
        attributeValueClass.getSimpleName(),
        clazzSimpleName,
        attributeName,
        attributeValue.toString()
      );
      return result;
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  public List<T> findAllBy(String attributeName, Object[] attributeValues) {
    try {
      Class<?>[] params = new Class<?>[] { List.class };
      String resolverName = "findAllBy" + toPascalCase(attributeName) + "In";
      Method methodToInvoke = getMethodToInvoke(resolverName, params, dao);
      final List<Object> attributeValuesAsList = Arrays.asList(attributeValues);
      final List<T> result = (List<T>) methodToInvoke.invoke(
        dao,
        attributeValuesAsList
      );
      logInfo(
        "findAllBy(String attributeName, Object[] attributeValues)",
        "found {} {} by provided attribute values: {}",
        result.size(),
        clazzSimpleNamePlural,
        Arrays.toString(attributeValues)
      );
      return result;
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  public Optional<T> findOne(Specification<T> specification) {
    final Optional result = dao.findOne(specification);
    logInfo(
      "findOne(Specification<{}> specification)",
      result.isPresent()
        ? "found one {} by provided specification"
        : "could not find {} by provided specification",
      clazzSimpleName
    );
    return result;
  }

  public List<T> findAll(Specification<T> specification) {
    final List all = dao.findAll(specification);
    logInfo(
      "findAll(Specification<{}> specification)",
      "found {} {} by provided specification",
      clazzSimpleName,
      all.size(),
      clazzSimpleNamePlural
    );
    return all;
  }

  public org.springframework.data.domain.Page findAll(
    Specification<T> specification,
    Pageable pageable
  ) {
    final org.springframework.data.domain.Page all = dao.findAll(
      specification,
      pageable
    );
    logInfo(
      "findAll(Specification<{}> specification, Pageable pageable)",
      "found {} {} by provided specification in {} pages",
      clazzSimpleName,
      all.getTotalElements(),
      clazzSimpleNamePlural,
      all.getTotalPages()
    );
    return all;
  }

  public List<T> findAll(Specification<T> specification, Sort sort) {
    final List all = dao.findAll(specification, sort);
    logInfo(
      "findAll(Specification<{}> specification, Sort sort)",
      "found {} {} by provided specification, sorted by {}",
      clazzSimpleName,
      all.size(),
      clazzSimpleNamePlural,
      sort.toString()
    );
    return all;
  }

  public long count(Specification<T> specification) {
    final long count = dao.count(specification);
    logInfo(
      "count(Specification<{}> specification)",
      "counted {} {} by provided specfication",
      clazzSimpleName,
      count,
      clazzSimpleNamePlural
    );
    return count;
  }

  public <TResult> TResult callQuery(String queryName, Object... args) {
    try {
      Class<?>[] params = new Class<?>[args.length];
      for (int i = 0; i < args.length; i++) params[i] = args[i].getClass();
      Method methodToInvoke = getMethodToInvoke(queryName, params, dao);
      final TResult result = (TResult) methodToInvoke.invoke(dao, args);
      logInfo(
        "callQuery(String queryName, Object... args)",
        Collection.class.isAssignableFrom(result.getClass())
          ? String.format(
            "fetched %d records from database with query '%s'",
            ((Collection) result).size(),
            queryName
          )
          : String.format(
            "fetched %s from database with query '%s'",
            result.getClass().getSimpleName(),
            queryName
          )
      );
      return result;
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  public T cascadeUpdate(T toUpdate, T source) {
    final T updated = (T) cascadeUpdateImpl(toUpdate, source);
    logInfo(
      "cascadeUpdate({} toUpdate, {} source)",
      "cascade updated {}",
      clazzSimpleName,
      clazzSimpleName,
      clazzSimpleName
    );
    return updated;
  }

  public <HasTs> List<T> createAndAddNewToCollectionIn(
    HasTs toAddTo,
    String fieldName,
    List<T> toAdd
  ) {
    final String toAddToClazzName = toAddTo.getClass().getSimpleName();
    GenericDao toAddDao = dao;
    GenericDao toAddToDao = daoMap.get(toAddToClazzName);

    toAddTo =
      (HasTs) toAddToDao
        .findById(
          reflectionCache
            .getEntitiesCache()
            .get(toAddToClazzName)
            .getId(toAddTo)
        )
        .orElse(null);
    if (toAddTo == null) throw new IllegalArgumentException(
      "Could not find an entity with the given id"
    );
    Method existingCollectionGetter = getMethodToInvoke(
      "get" + toPascalCase(fieldName),
      toAddTo
    );
    Collection<T> existingCollection = (Collection<T>) invoke(
      existingCollectionGetter,
      toAddTo
    );
    existingCollection.addAll(toAdd);
    Method existingCollectionSetter = getMethodToInvoke(
      "set" + toPascalCase(fieldName),
      toAddTo
    );
    invoke(existingCollectionSetter, toAddTo, existingCollection);

    toAddToDao.save(toAddTo);
    toAddDao.saveAll(toAdd);
    logInfo(
      "createAndAddNewToCollectionIn({} toAddTo, String fieldName, List<{}> toAdd)",
      "created {} {} and associated them with {} by id: {}",
      toAddToClazzName,
      clazzSimpleName,
      toAdd.size(),
      clazzSimpleNamePlural,
      toAddToClazzName,
      reflectionCache.getIdOf(toAddToClazzName, toAddTo)
    );
    return toAdd;
  }

  public <HasTs> List<T> associateExistingWithCollectionIn(
    HasTs toAssociateWith,
    String fieldName,
    List<T> toAssociate
  ) {
    GenericDao toAssociateDao = dao;
    final String toAssociateWithClazzName = toAssociateWith
      .getClass()
      .getSimpleName();
    GenericDao toAssociateWithDao = daoMap.get(toAssociateWithClazzName);

    toAssociate =
      toAssociateDao.findAllById(getIdList(toAssociate, reflectionCache));
    toAssociateWith =
      (HasTs) toAssociateWithDao
        .findById(
          reflectionCache
            .getEntitiesCache()
            .get(toAssociateWithClazzName)
            .getId(toAssociateWith)
        )
        .orElse(null);
    if (toAssociateWith == null) throw new IllegalArgumentException(
      "Could not find an entity with the given id"
    );
    Method existingCollectionGetter = getMethodToInvoke(
      "get" + toPascalCase(fieldName),
      toAssociateWith
    );
    Collection<T> existingCollection = (Collection<T>) invoke(
      existingCollectionGetter,
      toAssociateWith
    );
    existingCollection.addAll(toAssociate);
    Method existingCollectionSetter = getMethodToInvoke(
      "set" + toPascalCase(fieldName),
      toAssociateWith
    );
    invoke(existingCollectionSetter, toAssociateWith, existingCollection);
    toAssociateWithDao.save(toAssociateWith);

    logInfo(
      "associateExistingWithCollectionIn({} toAssociateWith, String fieldName, List<{}> toAssociate)",
      "associated {} {} with {} by id: {}",
      toAssociateWithClazzName,
      clazzSimpleName,
      toAssociate.size(),
      clazzSimpleNamePlural,
      toAssociateWithClazzName,
      reflectionCache.getIdOf(toAssociateWithClazzName, toAssociateWith)
    );
    return toAssociate;
  }

  public List<T> cascadeUpdateCollection(
    Collection<T> toUpdate,
    Collection<T> updated
  ) {
    Map<Object, T> updatedEntitiesMap = updated
      .stream()
      .collect(
        Collectors.toMap(
          updatedObj -> getId(updatedObj, reflectionCache),
          updatedObj -> updatedObj
        )
      );
    for (T entityToUpdate : toUpdate) {
      T updatedEntity = updatedEntitiesMap.get(
        getId(entityToUpdate, reflectionCache)
      );
      cascadeUpdateImpl(entityToUpdate, updatedEntity);
    }
    logInfo(
      "cascadeUpdateCollection(Iterable<{}> toUpdate, Iterable<{}> updated)",
      "cascade updated collection of {}",
      clazzSimpleName,
      clazzSimpleName,
      clazzSimpleNamePlural
    );
    return dao.saveAll(toUpdate);
  }

  private Object cascadeUpdateImpl(Object toUpdate, Object source) {
    Class<?> currentClazz = toUpdate.getClass();
    String currentClazzName = currentClazz.getSimpleName();
    logInfo(
      "cascadeUpdateImpl({} toUpdate, {} source)",
      "cascade updating {}",
      currentClazzName,
      currentClazzName,
      currentClazzName
    );
    Collection<Field> fieldsToUpdate = reflectionCache
      .getEntitiesCache()
      .get(currentClazz.getSimpleName())
      .getCascadeUpdatableFields();
    for (Field currentField : fieldsToUpdate) {
      try {
        currentField.setAccessible(true);
        Object sourceFieldValue = currentField.get(source);
        //if field value is null, there's nothing to update to
        if (sourceFieldValue == null) continue;
        //if field is an embedded entity, we need to recursively update all of its fields
        if (isForeignKey(currentField, toUpdate)) {
          Object targetFieldToUpdateValue = currentField.get(toUpdate);
          cascadeUpdateImpl(targetFieldToUpdateValue, sourceFieldValue);
          reflectionCache
            .getEntitiesCache()
            .get(currentField.getType().getSimpleName())
            .getRelationshipSyncronizer()
            .trySetBackpointer(
              currentField,
              targetFieldToUpdateValue,
              toUpdate
            );
        }
        //if field is a foreign key collection, that's outside of this use case
        else if (!isForeignKeyCollection(currentField)) currentField.set(
          toUpdate,
          sourceFieldValue
        ); //else, (...finally) update field value
      } catch (Exception e) {
        e.printStackTrace();
        throw new RuntimeException(e);
      }
    }
    return daoMap.get(currentClazz.getSimpleName()).save(toUpdate);
  }

  private boolean isForeignKeyCollection(Field f) {
    f.setAccessible(true);
    return (
      f.isAnnotationPresent(OneToMany.class) ||
      f.isAnnotationPresent(ManyToMany.class)
    );
  }

  private boolean isForeignKey(Field currentField, Object owner) {
    try {
      currentField.setAccessible(true);
      boolean isForeignKey =
        currentField.isAnnotationPresent(OneToOne.class) ||
        currentField.isAnnotationPresent(ManyToOne.class);
      if (isForeignKey) {
        if (currentField.get(owner) == null) currentField.set(
          owner,
          defaultInstanceOf(currentField.getType())
        );
        return true;
      }
      return false;
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  private Object defaultInstanceOf(Class<?> type) {
    return reflectionCache
      .getEntitiesCache()
      .get(type.getSimpleName())
      .getDefaultInstance();
  }

  private Method getMethodToInvoke(String resolverName, Object instance) {
    return getMethodToInvoke(resolverName, new Class<?>[] {}, instance);
  }

  private Method getMethodToInvoke(
    String resolverName,
    Class<?>[] params,
    Object instance
  ) {
    Method methodToInvoke = reflectionCache
      .getResolversCache()
      .get(immutableEntry(resolverName, params));
    if (methodToInvoke == null) {
      try {
        if (params.length > 0) methodToInvoke =
          instance
            .getClass()
            .getMethod(resolverName, params); else methodToInvoke =
          instance.getClass().getMethod(resolverName);
      } catch (NoSuchMethodException e) {
        throw new RuntimeException(e);
      }
      reflectionCache
        .getResolversCache()
        .put(immutableEntry(resolverName, params), methodToInvoke);
    }
    return methodToInvoke;
  }

  private Object invoke(Method method, Object instance, Object... args) {
    try {
      if (args.length > 0) return method.invoke(
        instance,
        args
      ); else return method.invoke(instance);
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

  public Page<T> freeTextSearchBy(FreeTextSearchPageRequest request) {
    return freeTextSearchBy(request, -1);
  }

  public Page<T> freeTextSearchBy(
    FreeTextSearchPageRequest request,
    long totalCount
  ) {
    try {
      if (
        request.getSearchTerm() == null || request.getSearchTerm().equals("")
      ) throw new IllegalArgumentException(
        "Illegal attempt to search for " +
        clazzSimpleNamePlural +
        " with null or blank string"
      );
      DatafiStaticUtils.validateSortByIfNonNull(
        clazz,
        request.getSortBy(),
        reflectionCache
      );
      Pageable paginator = DatafiStaticUtils.generatePageRequest(
        request,
        totalCount
      );
      Method methodToInvoke = getMethodToInvoke(
        "freeTextSearch",
        new Class<?>[] { String.class, Pageable.class },
        dao
      );
      val result = (org.springframework.data.domain.Page) methodToInvoke.invoke(
        dao,
        request.getSearchTerm(),
        paginator
      );
      logInfo(
        "freeTextSearchBy(String searchTerm)",
        "found {} {} by searchTerm '{}'",
        result.getTotalElements(),
        clazzSimpleNamePlural,
        request.getSearchTerm()
      );
      return new Page<>(result);
    } catch (Exception e) {
      logError(
        "freeTextSearchBy(String searchTerm, int offset, int limit, String sortBy, Sort.Direction sortDirection)",
        e.toString()
      );
      throw new RuntimeException(e);
    }
  }

  public <A extends Archivable> A archive(A input) {
    Object id = cachedEntityTypeInfo.getId(input);
    final String simpleName = input.getClass().getSimpleName();
    T toArchive = findById(id).orElse(null);
    if (toArchive == null) DatafiStaticUtils.throwEntityNotFoundException(
      simpleName,
      id
    );
    ((A) toArchive).setIsArchived(true);
    final A saved = (A) save(toArchive);
    logInfo(
      "archive({} input)",
      "archived {} with id {}",
      clazzSimpleName,
      clazzSimpleName,
      id.toString()
    );
    return saved;
  }

  public <A extends Archivable> A deArchive(A input) {
    Object id = cachedEntityTypeInfo.getId(input);
    final String simpleName = input.getClass().getSimpleName();
    T toDeArchive = findById(id).orElse(null);
    if (toDeArchive == null) DatafiStaticUtils.throwEntityNotFoundException(
      simpleName,
      id
    );
    ((A) toDeArchive).setIsArchived(false);
    final A saved = (A) save(toDeArchive);
    logInfo(
      "deArchive({} input)",
      "de-archived {} with id {}",
      clazzSimpleName,
      clazzSimpleName,
      id.toString()
    );
    return saved;
  }

  public <A extends Archivable> List<A> archiveCollection(Collection<A> input) {
    List<Object> ids = DatafiStaticUtils.getIdList(input, reflectionCache);
    List<T> toArchive = findAllById(ids);
    toArchive.forEach(item -> ((A) item).setIsArchived(true));
    final List<A> saved = (List<A>) saveAll(toArchive);
    logInfo(
      "archiveCollection(Collection<{}> input)",
      "archived {} {}",
      clazzSimpleName,
      saved.size(),
      clazzSimpleNamePlural
    );
    return saved;
  }

  public <A extends Archivable> List<A> deArchiveCollection(
    Collection<A> input
  ) {
    List<Object> ids = DatafiStaticUtils.getIdList(input, reflectionCache);
    List<T> toDeArchive = findAllById(ids);
    toDeArchive.forEach(item -> ((A) item).setIsArchived(false));
    final List<A> saved = (List<A>) saveAll(toDeArchive);
    logInfo(
      "deArchiveCollection(Collection<{}> input)",
      "de-archived {} {}",
      clazzSimpleName,
      saved.size(),
      clazzSimpleNamePlural
    );
    return saved;
  }
}
