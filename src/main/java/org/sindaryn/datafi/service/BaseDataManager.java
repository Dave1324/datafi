package org.sindaryn.datafi.service;

import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.val;
import org.sindaryn.datafi.persistence.GenericDao;
import org.sindaryn.datafi.reflection.CachedEntityType;
import org.sindaryn.datafi.reflection.ReflectionCache;
import org.springframework.aop.framework.Advised;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Example;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import javax.persistence.ManyToOne;
import javax.persistence.OneToOne;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.*;

import static com.google.common.collect.Maps.immutableEntry;
import static org.sindaryn.datafi.StaticUtils.*;

@Service
@SuppressWarnings("unchecked")
@NoArgsConstructor
@RequiredArgsConstructor
public abstract class BaseDataManager<T> {
    @NonNull
    private Class<T> clazz;
    private String clazzSimpleName;
    @Autowired
    protected ReflectionCache reflectionCache;
    /**
     * compile a list of all the the jpa repositories which were
     * autogenerated at compile time, and map each data access object
     * - or 'dao' to the name of its respective jpa repository.
     */
    private Map<String, GenericDao> daoMap;
    private GenericDao dao;
    @Autowired//autowiring daos via proxy because cannot autowire directly in abstract class
    private DaoCollector daoCollector;
    /*@Autowired
    private EntityTypeRuntimeResolver<T> typeRuntimeResolver;*/

    public void setType(Class<T> type){
        this.clazz = type;
        this.clazzSimpleName = type.getSimpleName();
        dao = daoMap.get(clazzSimpleName);
    }

    @PostConstruct
    private void init(){
        daoMap = new HashMap<>();
        List<? extends GenericDao> daos = daoCollector.getDaos();
        daos.forEach(dao -> {
            String entityName = extractEntityName(dao);
            if(entityName != null)
                daoMap.put(entityName, dao);
        });
        if(clazz != null)
            setType(clazz);
    }

    //spring framework instantiates proxies for each autowired instance.
    //if we want the actual name of the actual bean, we need to
    //'deproxy' the instance.
    private String extractEntityName(GenericDao dao) {
        val interfaces = ((Advised)dao).getProxiedInterfaces();
        String daoName = "";
        for(Class<?> interface_ : interfaces){
            if(interface_.getSimpleName().contains("Dao")){
                daoName = interface_.getSimpleName();
                break;
            }
        }
        int endIndex = daoName.indexOf("Dao");
        return endIndex != -1 ? daoName.substring(0, endIndex) : null;
    }

    public List<T> findAll(){return daoMap.get(clazzSimpleName).findAll();}
    
    public List<T> findAll(Sort sort) {
        return dao.findAll(sort);
    }

    public Page<T> findAll(Pageable pageable) {return dao.findAll(pageable);}

    public List<T> findAllById(Iterable<?> iterable) {return dao.findAllById(iterable);}

    public long count() {return dao.count();}

    public void deleteById(Object id) {
        dao.deleteById(id);
    }

    public void delete(T t) {
        dao.delete(t);
    }

    public void deleteAll(Iterable<? extends T> iterable) {
        dao.deleteAll(iterable);
    }

    public void deleteAll() {
        dao.deleteAll();
    }

    public <S extends T> S save(S s) {
        return (S) dao.save(s);
    }

    public <S extends T> List<S> saveAll(Iterable<S> iterable) {
        return dao.saveAll(iterable);
    }

    public Optional<T> findById(Object id) {
        return dao.findById(id);
    }

    public boolean existsById(Object id) {
        return dao.existsById(id);
    }

    public void flush() {
        dao.flush();
    }

    public <S extends T> S saveAndFlush(S s) {
        return (S) dao.saveAndFlush(s);
    }

    public void deleteInBatch(Iterable<T> iterable) {
        dao.deleteInBatch(iterable);
    }

    public void deleteAllInBatch() {
        dao.deleteAllInBatch();
    }

    public T getOne(Object id) {
        return (T) dao.getOne(id);
    }

    public <S extends T> Optional<S> findOne(Example<S> example) {
        return dao.findOne(example);
    }

    public <S extends T> List<S> findAll(Example<S> example) {
        return dao.findAll(example);
    }

    public <S extends T> List<S> findAll(Example<S> example, Sort sort) {
        return dao.findAll(example, sort);
    }

    public <S extends T> Page<S> findAll(Example<S> example, Pageable pageable) {
        return dao.findAll(example, pageable);
    }

    public <S extends T> long count(Example<S> example) {
        return dao.count(example);
    }

    public <S extends T> boolean exists(Example<S> example) {
        return dao.exists(example);
    }


    public List<T> getBy(String attributeName, Object attributeValue){
        try{
            Class<?>[] params = new Class<?>[]{attributeValue.getClass()};
            String resolverName = "findBy" + toPascalCase(attributeName);
            Method methodToInvoke = getMethodToInvoke(resolverName, params, dao);
            return (List<T>) methodToInvoke.invoke(dao, new Object[]{attributeValue});
        }catch (Exception e){
            throw new RuntimeException(e);
        }
    }

    public Optional<T> getByUnique(String attributeName, Object attributeValue){
        try{
            Class<?>[] params = new Class<?>[]{attributeValue.getClass()};
            String resolverName = "findBy" + toPascalCase(attributeName);
            Method methodToInvoke = getMethodToInvoke(resolverName, params, dao);
            return (Optional<T>) methodToInvoke.invoke(dao, new Object[]{attributeValue});
        }catch (Exception e){
            throw new RuntimeException(e);
        }
    }

    public List<T> getAllBy(String attributeName, Object[] attributeValues){
        try{
            Class<?>[] params = new Class<?>[]{List.class};
            String resolverName = "findAllBy" + toPascalCase(attributeName) + "In";
            Method methodToInvoke = getMethodToInvoke(resolverName, params, dao);
            return (List<T>) methodToInvoke.invoke(dao, Arrays.asList(attributeValues));
        }catch (Exception e){
            throw new RuntimeException(e);
        }
    }

    public Optional<T> findOne(Specification<T> specification) {
        return dao.findOne(specification);
    }

    public List<T> findAll(Specification<T> specification) {
        return dao.findAll(specification);
    }

    public Page<T> findAll(Specification<T> specification, Pageable pageable) {
        return dao.findAll(specification, pageable);
    }

    public List<T> findAll(Specification<T> specification, Sort sort) {
        return dao.findAll(specification, sort);
    }

    public long count(Specification<T> specification) {
        return dao.count(specification);
    }

    public List<T> selectByResolver(String resolverName, Object... args){
        try{
            Class<?>[] params = new Class<?>[args.length];
            for (int i = 0; i < args.length; i++) params[i] = args[i].getClass();
            Method methodToInvoke = getMethodToInvoke(resolverName, params, dao);
            return (List<T>) methodToInvoke.invoke(dao, args);
        }catch (Exception e){
            throw new RuntimeException(e);
        }
    }

    public T cascadedUpdate(T toUpdate, T source){
        return (T) cascadedUpdateImpl(toUpdate, source);
    }

    public<HasTs> List<T> addNewToCollectionIn(HasTs toAddTo, String fieldName, List<T> toAdd){

        GenericDao toAddDao = dao;
        final String toAddToName = toAddTo.getClass().getSimpleName();
        GenericDao toAddToDao = daoMap.get(toAddToName);

        toAddTo = (HasTs) toAddToDao.findById(reflectionCache.getEntitiesCache().get(toAddToName).invokeGetter(toAddTo, "id")).orElse(null);
        if(toAddTo == null) throw new IllegalArgumentException("Could not find an entity with the given id");
        Method existingCollectionGetter = getMethodToInvoke("get" + toPascalCase(fieldName) ,toAddTo);
        Collection<T> existingCollection = (Collection<T>) invoke(existingCollectionGetter, toAddTo);
        existingCollection.addAll(toAdd);
        Method existingCollectionSetter = getMethodToInvoke("set" + toPascalCase(fieldName) ,toAddTo);
        invoke(existingCollectionSetter, toAddTo, existingCollection);

        toAddToDao.save(toAddTo);
        toAddDao.saveAll(toAdd);
        return toAdd;
    }

    public<HasTs> List<T> attachExistingToCollectionIn(HasTs toAddTo, String fieldName, List<T> toAttach){

        GenericDao toAttachDao = dao;
        final String toAttachToName = toAddTo.getClass().getSimpleName();
        GenericDao toAttachToDao = daoMap.get(toAttachToName);

        toAttach = toAttachDao.findAllById(idList(toAttach));
        toAddTo = (HasTs) toAttachToDao.findById(reflectionCache.getEntitiesCache().get(toAttachToName).invokeGetter(toAddTo, "id")).orElse(null);
        if(toAddTo == null) throw new IllegalArgumentException("Could not find an entity with the given id");
        Method existingCollectionGetter = getMethodToInvoke("get" + toPascalCase(fieldName) ,toAddTo);
        Collection<T> existingCollection = (Collection<T>) invoke(existingCollectionGetter, toAddTo);
        existingCollection.addAll(toAttach);
        Method existingCollectionSetter = getMethodToInvoke("set" + toPascalCase(fieldName) ,toAddTo);
        invoke(existingCollectionSetter, toAddTo, existingCollection);
        toAttachToDao.save(toAddTo);
        return toAttach;
    }

    public List<T> cascadeUpdateCollection(Iterable<T> toUpdate, Iterable<T> updated){
        Iterator<T> updatedEntitiesIterator = updated.iterator();
        Iterator<T> entitiesToUpdateIterator = toUpdate.iterator();
        T entityToUpdate, updatedEntity;

        while(updatedEntitiesIterator.hasNext() && entitiesToUpdateIterator.hasNext()){
            updatedEntity = updatedEntitiesIterator.next();
            entityToUpdate = entitiesToUpdateIterator.next();
            cascadedUpdateImpl(entityToUpdate, updatedEntity);
        }
        return dao.saveAll(toUpdate);
    }

    private Object cascadedUpdateImpl(Object toUpdate, Object source){
        Class<?> currentClazz = toUpdate.getClass();
        Collection<Field> fieldsToUpdate = reflectionCache.getEntitiesCache().get(currentClazz.getSimpleName()).getCascadeUpdatableFields();
        for(Field currentField : fieldsToUpdate){
            try {
                currentField.setAccessible(true);
                Object sourceFieldValue = currentField.get(source);
                Object targetFieldValue = currentField.get(toUpdate);
                //if field value is null, there's nothing to update to
                if(sourceFieldValue == null) continue;
                //if field is an embedded entity, we need to recursively update all of its fields
                if(isForeignKey(currentField, toUpdate))
                    cascadedUpdateImpl(targetFieldValue, sourceFieldValue);
                    //if field is a collection, that's outside of this use case,
                else
                    //else, (...finally) update field value
                    currentField.set(toUpdate, sourceFieldValue);
            } catch (Exception e) {
                e.printStackTrace();
                throw new RuntimeException(e);
            }
        }
        return daoMap.get(currentClazz.getSimpleName()).save(toUpdate);
    }

    private boolean isForeignKey(Field currentField, Object owner) {
        try{
            currentField.setAccessible(true);
            boolean isForeignKey = currentField.isAnnotationPresent(OneToOne.class) ||
                    currentField.isAnnotationPresent(ManyToOne.class);
            if(isForeignKey) {
                if(currentField.get(owner) == null)
                    currentField.set(owner, defaultInstanceOf(currentField.getType()));
                return true;
            }
            return false;
        }catch (Exception e){
            throw new RuntimeException(e);
        }
    }

    private Object defaultInstanceOf(Class<?> type) {
        return reflectionCache.getEntitiesCache().get(type.getSimpleName()).getDefaultInstance();
    }

    private Method getMethodToInvoke(String resolverName, Object instance) {
        return getMethodToInvoke(resolverName, new Class<?>[]{}, instance);
    }

    private Method getMethodToInvoke(String resolverName, Class<?>[] params, Object instance){
        Method methodToInvoke = reflectionCache.getResolversCache().get(immutableEntry(resolverName, params));
        if(methodToInvoke == null){
            try {
                if(params.length > 0)
                    methodToInvoke = instance.getClass().getMethod(resolverName, params);
                else
                    methodToInvoke = instance.getClass().getMethod(resolverName);
            } catch (NoSuchMethodException e) {
                throw new RuntimeException(e);
            }
            reflectionCache.getResolversCache().put(immutableEntry(resolverName, params), methodToInvoke);
        }
        return methodToInvoke;
    }

    private Object invoke(Method method, Object instance, Object... args){
        try{
            if(args.length > 0) return method.invoke(instance, args);
            else return method.invoke(instance);
        }catch (Exception e){
            throw new RuntimeException(e);
        }
    }

    public List<Object> idList(Iterable<T> collection) {
        CachedEntityType entityType = reflectionCache.getEntitiesCache().get(clazzSimpleName);
        List<Object> ids = new ArrayList<>();
        collection.forEach(item -> ids.add(entityType.invokeGetter(item, "id")));
        return ids;
    }

    //implicit / default pagination
    public List<T> fuzzySearchBy(String searchTerm){
        return fuzzySearchBy(searchTerm, 0, 50);
    }

    //explicit pagination
    public List<T> fuzzySearchBy(String searchTerm, int offset, int limit){
        return fuzzySearchBy(searchTerm, offset, limit, null, null);
    }

    //explicit pagination with sort
    public List<T> fuzzySearchBy(String searchTerm, int offset, int limit, String sortBy, Sort.Direction sortDirection){
        try{
            if(searchTerm.equals(""))
                throw new IllegalArgumentException(
                        "Illegal attempt to search for " + toPlural(clazzSimpleName) + " with blank string"
                );
            validateSortByIfNonNull(clazz, sortBy, reflectionCache);
            Pageable paginator = generatePageRequest(offset, limit, sortBy, sortDirection);
            Method methodToInvoke =
                    getMethodToInvoke("fuzzySearch", new Class<?>[]{String.class, Pageable.class}, dao);
            Page<T> result = (Page<T>) methodToInvoke.invoke(dao, searchTerm, paginator);
            return result.getContent();
        }catch (Exception e){
            throw new RuntimeException(e);
        }
    }

}
